\documentclass[10pt,final]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=0.8in,bottom=0.8in, left=0.8in, right=1in]{geometry}
\setlength{\parindent}{0em}
\usepackage{blindtext}
\usepackage{graphicx}


\begin{document}

\title{"A Survey on Reactive Programming" - Résumé}

\author{Auteurs de l'article: Bainomugisha Andoni et al., Vrije Universiteteit Brussel, 2013}

\maketitle

\section{Contexte et définition}

La "programmation réactive" (Reactive Programming) est une solution de plus en plus populaire pour développer des applications interactives de type \textit{event-driven}. Elle fournit les abstractions essentielles à l'expression de programmes comme conséquences d'évènements extérieurs et en permettant au langage de gérer automatiquement les dépendances entre événements et traitements. En bref, elle permet au développeur d'exprimer dans le programme quoi faire, et laisse au langage la gestion automatique du moment où cela doit être fait.

Cette étude vise à décrire et comparer les différentes implémentations existantes de la RP et à identifier les challenges restants dans ce domaine.

\section{Axes d'approche}
L'étude utilise six axes d'approche pour la description des langages réactifs :

\begin{description}
    \item[Représentations des valeurs évolutives]
    La plupart des langages fournissent deux abstractions de base : les \textbf{\textit{behaviors}} pour la représentation des valeurs évoluant dans le temps de manière continue et les \textbf{\textit{events}} pour la représentation des valeurs évoluant dans le temps de manière discrètes.
    
    \item[Modèle d'évaluation]
    Le modèle d'évaluation définit comment les changements sont propagés dans le graphe de dépendance des valeurs et fonctions. Du point de vue du programmeurs, cette propagation est automatique. Cette propagation peut avoir lieu dans deux sens: 
    
    \textbf{\textit{Pull-Based}} (propagation demand-driven), où le calcul nécessitant la valeur évolutive doit la réclamer("pull") à la source (lazy evaluation).
    
    \textbf{\textit{Push-Based}} (propagation data-driven), où la source qui transmet le changement à toutes ses dépendances (eager evaluation).
    
    \item[Glitch Avoidance]
    Un \textit{glitch} survient si, a un moment, on peut voir des valeurs dans un état inconsistant. Les \textit{glitches} sont des erreurs qui surviennent lors de la propagation des changement lors d'un évènement. Par exemples, d'anciennes valeurs sont combinées avec des nouvelles afin de former un état intermédiaire n'ayant aucune consistance avec l'état du programme.
    
    \item[Lifting Operations]
    Le \textit{lifting} est la conversion d'opérateurs afin de les rendre capables de gérer des \textit{behaviors}.
    
    \item[Multidirectionnalité]
    Cette propriété définit la manière dont sont propagés les changements, qui est soit unidirectionelle soit multidirectionelle. Quand elle est multidirectionnelle, une expression est réévaluée quand n'importe quelle event/behavior qu'elle contient change. Sinon, on a un sens input -> output (graphe dirigé).
    
    \item[Support de la distribution]
    Un langage réactif supportant la distribution permet de créer des dépendances entre des traitements ou données distribués sur plusieurs noeuds. C'est un critère important car les applications interactives deviennement de plus en plus distribuées, mais c'est une chose difficile à implémenter.
\end{description}


\section{Langages}

L'étude distingue trois familles de langages réactifs: Les langages \textit{\textbf{FRP}} (Functional Reactive Programming, par ex. Fran) qui implémentent tous les concepts classiques et sont basés sur des langages fonctionnels, les \textit{\textbf{Cousins de la Programmation Réactive}} (par ex. .NET Rx), qui incluent certaines fonctionnalités des langages réactifs (propagation auto. des changements + autres), et les langages de type \textit{\textbf{Synchrone/Dataflow/Synchrone Dataflow}}, utilisés pour modeler des systèmes temps réel (par ex. LabView).

\section{Questions ouvertes et solutions}

La programmation réactive possède encore des zones d'ombres, très peu de langages réactifs
supportent la multi-directionnalité et la programmation distribuée. L'étude propose des pistes pour leur mitigation :
\begin{itemize}
    \item \textbf{Multi-directonnalité}
        \begin{itemize}
            \item Utiliser un système basé sur la programmation par contrainte mais pour des flux
            \item Expliciter la dépendance bi-directionnelle (certains langages)
        \end{itemize}
    \item \textbf{Glitches dans les systèmes distribués}
        \begin{itemize}
            \item Utiliser une entité centrale
            \item Mise en place d'une horloge commune
        \end{itemize}
    \item \textbf{Erreurs réseaux}
        \begin{itemize}
            \item Utilisation du pattern "publish/subscribe-style" (pas besoin d'être connecté au même moment)
        \end{itemize}
\end{itemize}

\section{Conclusion}

\end{document}
