\documentclass[10pt,final]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=0.8in,bottom=0.8in, left=0.8in, right=1in]{geometry}
\setlength{\parindent}{0em}
\usepackage{blindtext}
\usepackage{graphicx}


\begin{document}

\title{A Survey on Reactive Programming}

\author{Bainomugisha Andoni et al., Vrije Universiteteit Brussel, 2013}

\maketitle

\section{Contexte et définition}
De nous jours, les applications deviennent de plus en plus interactives et dirigées par des évènement (event-driven applications). Le problème est que le comportement de ces applications est difficile à contrôler et à prédire car les évènements externes ne sont pas sous contrôle.

La "programmation réactive" (reactive programming) est une solution pour les problèmes posés par la programmation évènementielle. Elle fournit les abstractions essentielles à l'expression de programmes comme conséquences d'évènements extérieurs et en permettant au langage de gérer automatiquement les dépendances de données. En bref, elle permet au développeur d'exprimer dans le programme quoi faire, et laisse au langage la gestion automatique du moment où cela doit être fait.

\section{Axes d'approche}
Six axes d'axes d'approche ont été définis.

\subsection{Représentations des valeurs évolutives}

L'abstraction des variables réactives est indispensable afin de faciliter l'écriture d'un programme réactif. La plupart des langages fournissent deux abstractions: les \textit{behaviors} (pour la représentation des valeurs évoluant dans le temps de manière continue) et les \textit{events} (pour la représentation des valeurs évoluant dans le temps de manière discrètes). On notera que pour les \textit{behaviors} la précision est directement liée à la fréquence d'horloge de la machine (plus elle est élevée, plus la précision est grande).

\subsection{Modèle d'évaluation}
Le modèle d'évaluation définit comment les changements sont propagés dans le graphe de dépendance des valeurs et fonctions. Du point de vue du programmeurs, cette propagation est automatique. Cette propagation peut avoir lieu dans deux sens: \textit{Pull-Based} ou \textit{Push-Based}.

Dans la variante \textit{Pull-Based}, le calcul nécessitant la valeur évolutive doit la réclamer("pull") à la source. La propagation est donc \textit{demand drivent} et l'évaluation des la valeur est paresseuse \textit{lazy evaluation}. Un problème peut survenir si trop de changements s'accumulent sans être exécutés, dans ce cas, l'appel à la nouvelle valeur peut provoquer une latence significative.

Dans la variante \textit{Push-Based}, c'est la source qui, a chaque changement de valeur, transmet le changement à toutes ses dépendances. La propagation est donc \textit{data drivent} et l'évaluation des la valeur est stricte \textit{eager evaluation}. Ici le problème principal est les calculs faits pour rien, car toutes les dépendances sont recalculées à chaque changement, mais pas forcément lues.

\subsection{Glitch Avoidance}
Un \textit{glitch} survient si, a un moment, on peut voir des valeurs dans un état inconsistant. Les \textit{glitches} sont des erreurs qui surviennent lors de la propagation des changement lors d'un évènement. Par exemples, d'anciennes valeurs sont combinées avec des nouvelles afin de former un état intermédiaire n'ayant aucune consistance avec l'état du programme.

\subsection{Lifting Operations}
Le \textit{lifting} est la conversion d'opérateurs afin de les rendre capables de gérer des \textit{behaviors}.

\subsection{multidirectionality}

\subsection{support for distribution}

\section{Langages}
Trois familles: FRP siblings, cousins of reactive programming, others (trop long)

\section{Questions ouvertes et solutions}

\begin{itemize}
    \item Multi-directonnalité
        \begin{itemize}
            \item Utiliser un système basé sur la programmation par contrainte mais pour des flux
            \item Expliciter la dépendance bi-directionnelle (certain langage)
        \end{itemize}
    \item Glitchs dans les systèmes distribués
        \begin{itemize}
            \item Utiliser une entité centrale
            \item Mise en place d'une horloge commune
        \end{itemize}
    \item Erreurs réseaux
        \begin{itemize}
            \item Utilisation du pattern "publish/subscribe-style" (pas besoin d'être connecté au
                même moment)
        \end{itemize}
\end{itemize}


\section{Conclusion}

\end{document}
